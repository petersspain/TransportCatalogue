**Транспортный справочник**

Сформированный транспортный справочник поддерживает следующие запросы:

1. Получение информации о маршруте
1. Получение информации об остановке
1. Получение графического представления транспортного справочника в формате svg
1. Построение оптимального маршрута между остановками

Формирование транспортного справочника и ответ на запросы по представленному справочнику разделено на две программы:

1. Программа make\_base: создание базы транспортного справочника по запросам base\_requests и её сериализация в файл. Для запуска это программы необходимо указать ключ make\_base.
1. Программа process\_requests: десериализация базы из файла и использование её для ответов на запросы stat\_requests. Для запуска этой программы необходимо указать ключ process\_requests.
### **Программа make\_base**
Задача программы make\_base — построить базу и сериализовать её в файл с указанным именем.
### **Формат входных данных**
Входные данные поступают программе из stdin в формате JSON-объекта, который имеет на верхнем уровне следующую структуру:

{

`  `"base\_requests": [ ... ],

`  `"routing\_settings": { ... },  

`  `"render\_settings": { ... },

`  `"serialization\_settings": { ... },

} 

Это словарь, содержащий ключи:

- base\_requests — массив с описанием автобусных маршрутов и остановок,
- routing\_settings – словарь с настройками маршрутизации,
- render\_settings – словарь с настройками визуализации карты,
- serialization\_settings – словарь с настройками сериализации.
### **Описание базы маршрутов**
Массив base\_requests содержит элементы двух типов: маршруты и автобусы. Эти элементы перечисляются в произвольном порядке.

Пример описания остановки:

{

`  `"type": "Stop",

`  `"name": "Электросети",

`  `"latitude": 43.598701,

`  `"longitude": 39.730623,

`  `"road\_distances": {

`    `"Улица Докучаева": 3000,

`    `"Улица Лизы Чайкиной": 4300

`  `}

} 

Описание остановки — словарь с ключами:

- type — строка, равная "Stop", означает, что объект описывает остановку;
- name — название остановки;
- latitude и longitude задают координаты широты и долготы остановки;
- road\_distances — словарь, задающий расстояние до соседних остановок. Ключ — название остановки, значение — целое число в метрах.

Пример описания автобусного маршрута:

{

`  `"type": "Bus",

`  `"name": "14",

`  `"stops": [

`    `"Улица Лизы Чайкиной",

`    `"Электросети",

`    `"Улица Докучаева",

`    `"Улица Лизы Чайкиной"

`  `],

`  `"is\_roundtrip": true

} 

Описание автобусного маршрута — словарь с ключами:

- type — строка "Bus", означающая, что объект описывает автобусный маршрут;
- name — название маршрута;
- stops — массив с названиями остановок, через которые проходит автобусный маршрут. У кольцевого маршрута название последней остановки дублирует название первой. Например: ["stop1", "stop2", "stop3", "stop1"];
- is\_roundtrip — значение типа bool. Указывает, кольцевой маршрут или нет.
### **Настройки маршрутизации**
Структура словаря routing\_settings:

"routing\_settings": {

`      `"bus\_wait\_time": 6,

`      `"bus\_velocity": 40

} 

- bus\_wait\_time — время ожидания автобуса на остановке, в минутах. Считается, что, когда бы человек ни пришёл на остановку и какой бы ни была эта остановка, он будет ждать любой автобус в точности указанное количество минут. Значение — целое число от 1 до 1000.
- bus\_velocity — скорость автобуса, в км/ч. Считается, что скорость любого автобуса постоянна и в точности равна указанному числу. Время стоянки на остановках не учитывается, время разгона и торможения тоже. Значение — вещественное число от 1 до 1000.

Данная конфигурация задаёт время ожидания, равным 6 минутам, и скорость автобусов, равной 40 километрам в час.
### **Настройки визуализации**
Структура словаря render\_settings:

{

`  `"width": 1200.0,

`  `"height": 1200.0,

`  `"padding": 50.0,

`  `"line\_width": 14.0,

`  `"stop\_radius": 5.0,

`  `"bus\_label\_font\_size": 20,

`  `"bus\_label\_offset": [7.0, 15.0],

`  `"stop\_label\_font\_size": 20,

`  `"stop\_label\_offset": [7.0, -3.0],

`  `"underlayer\_color": [255, 255, 255, 0.85],

`  `"underlayer\_width": 3.0,

`  `"color\_palette": [

`    `"green",

`    `[255, 160, 0],

`    `"red"

`  `]

} 

- width и height — ключи, которые задают ширину и высоту в пикселях. Вещественное число в диапазоне от 0 до 100000.
- padding — отступ краёв карты от границ SVG-документа. Вещественное число не меньше 0 и меньше min(width, height)/2.
- line\_width — толщина линий, которыми рисуются автобусные маршруты. Вещественное число в диапазоне от 0 до 100000.
- stop\_radius — радиус окружностей, которыми обозначаются остановки. Вещественное число в диапазоне от 0 до 100000.
- bus\_label\_font\_size — размер текста, которым написаны названия автобусных маршрутов. Целое число в диапазоне от 0 до 100000.
- bus\_label\_offset — смещение надписи с названием маршрута относительно координат конечной остановки на карте. Массив из двух элементов типа double. Задаёт значения свойств dx и dy SVG-элемента <text>. Элементы массива — числа в диапазоне от –100000 до 100000.
- stop\_label\_font\_size — размер текста, которым отображаются названия остановок. Целое число в диапазоне от 0 до 100000.
- stop\_label\_offset — смещение названия остановки относительно её координат на карте. Массив из двух элементов типа double. Задаёт значения свойств dx и dy SVG-элемента <text>. Числа в диапазоне от –100000 до 100000.
- underlayer\_color — цвет подложки под названиями остановок и маршрутов. Формат хранения цвета будет ниже.
- underlayer\_width — толщина подложки под названиями остановок и маршрутов. Задаёт значение атрибута stroke-width элемента <text>. Вещественное число в диапазоне от 0 до 100000.
- color\_palette — цветовая палитра. Непустой массив.

Цвет можно указать:

- в виде строки, например, "red" или "black";
- в массиве из трёх целых чисел диапазона [0, 255]. Они определяют r, g и b компоненты цвета в формате svg::Rgb. Цвет [255, 16, 12] будет выведен как rgb(255, 16, 12);
- в массиве из четырёх элементов: три целых числа в диапазоне от [0, 255] и одно вещественное число в диапазоне от [0.0, 1.0]. Они задают составляющие red, green, blue и opacity цвета формата svg::Rgba. Цвет, заданный как [255, 200, 23, 0.85], будет выведен как rgba(255, 200, 23, 0.85).

Гарантируется, что каждый цвет задан в одном из этих трёх форматов.
### **Настройки сериализации**
Структура словаря serialization\_settings:

"serialization\_settings": {

`      `"file": "transport\_catalogue.db"

} 

- file — строка с названием файла, в который нужно сохранить сериализованную базу.
### **Программа process\_requests**
Задача программы process\_requests — десериализация базы из файла и использование её для вывода JSON с ответами на запросы stat\_requests.
### **Формат входных данных**
На вход программе process\_requests подаётся файл с сериализованной базой (результат работы make\_base), а также — через стандартный поток ввода — JSON, имеющий следующую структуру:

{

`  "serialization\_settings": { ... },`

`  `"stat\_requests": [ ... ]

} 

Это словарь, содержащий ключи:

- stat\_requests – массив с запросами к транспортному справочнику,
- serialization\_settings – настройки сериализации в формате, аналогичном этой же секции на входе make\_base. А именно, в ключе file указывается название файла, из которого нужно считать сериализованную базу.
### **Формат запросов и ответов к транспортному справочнику**
Массив stat\_requests содержит запросы к транспортному справочнику. В ответ них приложение должно в виде JSON-массива ответов вывести в stdout:

[

`  `{ ответ на первый запрос },

`  `{ ответ на второй запрос },

`  `...

`  `{ ответ на последний запрос }

] 

Каждый запрос — словарь с обязательными ключами id и type, которые задают уникальный числовой идентификатор запроса и его тип.

На каждый запрос массива stat\_requests в выходном JSON-массиве должен содержаться ответ в виде словаря с обязательным ключом request\_id, значение которого равно id соответствующего запроса.

Порядок следования ответов на запросы в выходном массиве должен совпадать с порядком запросов в массиве stat\_requests.
### **Получение информации о маршруте (запрос Bus)**
Запрос на получение информации об автобусном маршруте:

{

`  `"id": 12345678,

`  `"type": "Bus",

`  `"name": "14"

} 

Ключ name задаёт название маршрута, для которого приложение должно вывести статистическую информацию.

В ответ на этот запрос должен быть выдан ответ в виде словаря:

{

`  `"curvature": 2.18604,

`  `"request\_id": 12345678,

`  `"route\_length": 9300,

`  `"stop\_count": 4,

`  `"unique\_stop\_count": 3

} 

В словаре содержатся ключи:

- curvature — число типа double, задающее извилистость маршрута. Извилистость равна отношению длины дорожного расстояния маршрута к длине географического расстояния;
- request\_id — целое число, равное id соответствующего запроса Bus;
- route\_length — целое число, равное длине маршрута в метрах;
- stop\_count — количество остановок на маршруте;
- unique\_stop\_count — количество уникальных остановок на маршруте.

На кольцевом маршруте, заданном остановками A, B, C, A, количество остановок равно четырём, а количество уникальных остановок равно трём.

На некольцевом маршруте, заданном остановками A, B и C, количество остановок равно пяти (A, B, C, B, A), а уникальных — равно трём.

Если в справочнике нет маршрута с указанным названием, ответ будет такой:

{

`  `"request\_id": 12345678,

`  `"error\_message": "not found"

} 
### **Получение информации об остановке (запрос Stop)**
Запрос на получение информации об автобусной остановке:

{

`  `"id": 12345,

`  `"type": "Stop",

`  `"name": "Улица Докучаева"

} 

Ключ name задаёт название остановки.

Ответ на запрос:

{

`  `"buses": [

`      `"14", "22к"

`  `],

`  `"request\_id": 12345

} 

Ключи ответа имеют следующее значение:

- buses — массив названий автобусных маршрутов, проходящих через эту остановку. Названия маршрутов отсортированы в лексикографическом порядке.
- request\_id – целое число, равное id соответствующего запроса Stop.

Если в справочнике нет остановки с переданным названием, ответ на запрос будет такой:

{

`  `"request\_id": 12345,

`  `"error\_message": "not found"

} 
### **Запрос на получение изображения (запрос Map)**
{

`  `"type": "Map",

`  `"id": 11111

} 

Ответ на запрос:

{

`  `"map": "<?xml version=\"1.0\" encoding=\"UTF-8\" ?>\n<svg xmlns=\"http://www.w3.org/2000/svg\" version=\"1.1\">\n  <polyline points=\"100.817,170 30,30 100.817,170\" fill=\"none\" stroke=\"green\" stroke-width=\"14\" stroke-linecap=\"round\" stroke-linejoin=\"round\"/>\n  <text fill=\"rgba(255,255,255,0.85)\" stroke=\"rgba(255,255,255,0.85)\" stroke-width=\"3\" stroke-linecap=\"round\" stroke-linejoin=\"round\" x=\"100.817\" y=\"170\" dx=\"7\" dy=\"15\" font-size=\"20\" font-family=\"Verdana\" font-weight=\"bold\">114</text>\n  <text fill=\"green\" x=\"100.817\" y=\"170\" dx=\"7\" dy=\"15\" font-size=\"20\" font-family=\"Verdana\" font-weight=\"bold\">114</text>\n  <text fill=\"rgba(255,255,255,0.85)\" stroke=\"rgba(255,255,255,0.85)\" stroke-width=\"3\" stroke-linecap=\"round\" stroke-linejoin=\"round\" x=\"30\" y=\"30\" dx=\"7\" dy=\"15\" font-size=\"20\" font-family=\"Verdana\" font-weight=\"bold\">114</text>\n  <text fill=\"green\" x=\"30\" y=\"30\" dx=\"7\" dy=\"15\" font-size=\"20\" font-family=\"Verdana\" font-weight=\"bold\">114</text>\n  <circle cx=\"100.817\" cy=\"170\" r=\"5\" fill=\"white\"/>\n  <circle cx=\"30\" cy=\"30\" r=\"5\" fill=\"white\"/>\n  <text fill=\"rgba(255,255,255,0.85)\" stroke=\"rgba(255,255,255,0.85)\" stroke-width=\"3\" stroke-linecap=\"round\" stroke-linejoin=\"round\" x=\"100.817\" y=\"170\" dx=\"7\" dy=\"-3\" font-size=\"20\" font-family=\"Verdana\">Морской вокзал</text>\n  <text fill=\"black\" x=\"100.817\" y=\"170\" dx=\"7\" dy=\"-3\" font-size=\"20\" font-family=\"Verdana\">Морской вокзал</text>\n  <text fill=\"rgba(255,255,255,0.85)\" stroke=\"rgba(255,255,255,0.85)\" stroke-width=\"3\" stroke-linecap=\"round\" stroke-linejoin=\"round\" x=\"30\" y=\"30\" dx=\"7\" dy=\"-3\" font-size=\"20\" font-family=\"Verdana\">Ривьерский мост</text>\n  <text fill=\"black\" x=\"30\" y=\"30\" dx=\"7\" dy=\"-3\" font-size=\"20\" font-family=\"Verdana\">Ривьерский мост</text>\n</svg>",

`  `"request\_id": 11111

} 

Ключ map — строка с изображением карты в формате SVG.
### **Запрос на построение маршрута между двумя остановками (запрос Route)**
{

`      `"type": "Route",

`      `"from": "Biryulyovo Zapadnoye",

`      `"to": "Universam",

`      `"id": 4

} 

Помимо стандартных свойств id и type, такие запросы содержат ещё два:

- from — остановка, где нужно начать маршрут.
- to — остановка, где нужно закончить маршрут.

Оба значения — названия существующих в базе остановок. Однако они, возможно, не принадлежат ни одному автобусному маршруту. 

Данный запрос означает построение маршрута от остановки “Biryulyovo Zapadnoye” до остановки “Universam”.

На маршруте человек может использовать несколько автобусов. Один автобус даже можно использовать несколько раз, если на некоторых участках он делает большой крюк и проще срезать на другом автобусе.

Маршрут должен быть оптимален по времени. Если маршрутов с минимально возможным суммарным временем несколько, допускается вывести любой из них.

При прохождении маршрута время расходуется на два типа активностей:

- Ожидание автобуса. Всегда длится bus\_wait\_time минут.
- Поездка на автобусе. Всегда длится ровно такое количество времени, которое требуется для преодоления данного расстояния со скоростью bus\_velocity. Расстояние между остановками вычисляется по дорогам, то есть с использованием road\_distances.

На конечных остановках все автобусы высаживают пассажиров и уезжают в парк. Даже если человек едет на кольцевом — "is\_roundtrip": true — маршруте и хочет проехать мимо конечной, он будет вынужден выйти и подождать *тот же самый автобус* ровно bus\_wait\_time минут. 

Ответ на запрос Route устроен следующим образом:

{

`    `"request\_id": <id запроса>,

`    `"total\_time": <суммарное время>,

`    `"items": [

`        `<элементы маршрута>

`    `]

} 

total\_time — суммарное время в минутах, которое требуется для прохождения маршрута, выведенное в виде вещественного числа.

items — список элементов маршрута, каждый из которых описывает непрерывную активность пассажира, требующую временных затрат. А именно элементы маршрута бывают двух типов.

1. Wait — подождать нужное количество минут (в нашем случае всегда bus\_wait\_time) на указанной остановке:

{

`    `"type": "Wait",

`    `"stop\_name": "Biryulyovo",

`    `"time": 6

} 

2. Bus — проехать span\_count остановок (перегонов между остановками) на автобусе bus, потратив указанное количество минут:

{

`    `"type": "Bus",

`    `"bus": "297",

`    `"span\_count": 2,

`    `"time": 5.235

} 

Если маршрута между указанными остановками нет, выводится результат в следующем формате:

{

`    `"request\_id": <id запроса>,

`    `"error\_message": "not found"

} 

**Задача поиска оптимального маршрута данного вида сводится к задаче поиска кратчайшего пути во взвешенном ориентированном графе.**

Было предоставлено две небольшие библиотеки:

- graph.h — класс, реализующий взвешенный ориентированный граф,
- router.h — класс, реализующий поиск кратчайшего пути во взвешенном ориентированном графе.

О классах дополнительно известно следующее:

- Вершины и рёбра графа нумеруются автоинкрементно беззнаковыми целыми числами, хранящимися в типах VertexId и EdgeId: вершины нумеруются от нуля до количества вершин минус один в соответствии с пользовательской логикой. Номер очередного ребра выдаётся методом AddEdge; он равен нулю для первого вызова метода и при каждом следующем вызове увеличивается на единицу.
- Память, нужная для хранения графа, линейна относительно суммы количеств вершин и рёбер.
- Конструктор и деструктор графа имеют линейную сложность, а остальные методы константны или амортизированно константны.
- Маршрутизатор — класс Router — требует квадратичного относительно количества вершин объёма памяти, не считая памяти, требуемой для хранения кэша маршрутов.
- Конструктор маршрутизатора имеет сложность *O*(*V*3+*E*), где *V* — количество вершин графа, *E* — количество рёбер.
- Маршрутизатор не работает с графами, имеющими рёбра отрицательного веса.
- Построение маршрута на готовом маршрутизаторе линейно относительно **количества рёбер в маршруте**. Таким образом, основная нагрузка построения оптимальных путей ложится на конструктор.

Необходимо было:

- самостоятельно разобраться с понятиями графов и путями в них;
- придумать, как по транспортному справочнику построить граф, в котором путь наименьшего веса соответствует оптимальному маршруту на автобусах. Но сначала надо определиться, что в этом графе будет вершинами, а что — рёбрами;
- написать код построения графа и описания маршрута по пути, полученному от маршрутизатора.

В данном случае задача была решена путем закладывая одной вершины на остановку. Таким образом, время ожидания автобуса заложено в веса рёбер, соединяющих остановки.

Для решения задачи бинарной сериализации используется [Google Protocol Buffers](https://developers.google.com/protocol-buffers), или просто Protobuf, так что для работы программы необходимо иметь собранный пакет Protobuf.
